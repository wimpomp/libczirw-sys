/* automatically generated by rust-bindgen 0.72.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _CPP_CPPCONFIG_WRAPPER: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 15;
pub const __GLIBCXX__: u32 = 20250521;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_ASSERTIONS: u32 = 1;
pub const _GLIBCXX_VERBOSE_ASSERT: u32 = 1;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC23_SOURCE: u32 = 1;
pub const _ISOC2Y_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 41;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_HAVE_FLOAT128_MATH: u32 = 1;
pub const _GLIBCXX_MAY_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const _GLIBCXX_GTHREAD_USE_WEAK: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_FLOAT_IS_IEEE_BINARY32: u32 = 1;
pub const _GLIBCXX_DOUBLE_IS_IEEE_BINARY64: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARC4RANDOM: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_C99_FLT_EVAL_TYPES: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DECL_STRNLEN: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DIRFD: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FDOPENDIR: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETENTROPY: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINK_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_LSEEK: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_OPENAT: u32 = 1;
pub const _GLIBCXX_HAVE_O_NONBLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_SEMAPHORE: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SECURE_GETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STACKTRACE: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_MMAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNLINKAT: u32 = 1;
pub const _GLIBCXX_HAVE_USELOCALE: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const _GLIBCXX_LT_OBJDIR: &[u8; 7] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15] = b"version-unused\0";
pub const _GLIBCXX_STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_CAN_ALIGNAS_DESTRUCTIVE_SIZE: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_ARC: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_FUNCS: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CHDIR: u32 = 1;
pub const _GLIBCXX_USE_CHMOD: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_FSEEKO_FTELLO: u32 = 1;
pub const _GLIBCXX_USE_GETCWD: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INIT_PRIORITY_ATTRIBUTE: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_MKDIR: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_NL_LANGINFO_L: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_CXX20: u32 = 1;
pub const _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_FCHAR8_T: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GLIBCXX_X86_RDSEED: u32 = 1;
pub const _GLIBCXX_ZONEINFO_DIR: &[u8; 20] = b"/usr/share/zoneinfo\0";
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__glibcxx_assert_failPKciS0_S0_"]
    pub fn std___glibcxx_assert_fail(
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
        __function: *const ::std::os::raw::c_char,
        __condition: *const ::std::os::raw::c_char,
    ) -> !;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Defines an alias representing the error codes for the libCZIApi-module.\n In general, values greater than zero indicate an error condition; and values less\n or equal to zero indicate proper operation."]
pub type LibCZIApiErrorCode = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " The operation completed successfully."]
    #[link_name = "\u{1}_ZL22LibCZIApi_ErrorCode_OK"]
    pub static LibCZIApi_ErrorCode_OK: LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " An invalid argument was supplied to the function."]
    #[link_name = "\u{1}_ZL35LibCZIApi_ErrorCode_InvalidArgument"]
    pub static LibCZIApi_ErrorCode_InvalidArgument: LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " An invalid handle was supplied to the function (i.e. a handle which is either a bogus value or a handle which has already been destroyed)."]
    #[link_name = "\u{1}_ZL33LibCZIApi_ErrorCode_InvalidHandle"]
    pub static LibCZIApi_ErrorCode_InvalidHandle: LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " The operation failed due to an out-of-memory condition."]
    #[link_name = "\u{1}_ZL31LibCZIApi_ErrorCode_OutOfMemory"]
    pub static LibCZIApi_ErrorCode_OutOfMemory: LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " A supplied index was out of range."]
    #[link_name = "\u{1}_ZL35LibCZIApi_ErrorCode_IndexOutOfRange"]
    pub static LibCZIApi_ErrorCode_IndexOutOfRange: LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " A semantic error in using Lock/Unlock methods (e.g. of the bitmap object) was detected. Reasons could be\n an unbalanced number of Lock/Unlock calls, or the object was destroyed with a lock still held."]
    #[link_name = "\u{1}_ZL46LibCZIApi_ErrorCode_LockUnlockSemanticViolated"]
    pub static LibCZIApi_ErrorCode_LockUnlockSemanticViolated: LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " An unspecified error occurred."]
    #[link_name = "\u{1}_ZL36LibCZIApi_ErrorCode_UnspecifiedError"]
    pub static LibCZIApi_ErrorCode_UnspecifiedError: LibCZIApiErrorCode;
}
#[doc = " Defines an alias representing a \"handle to some object (created and used by the libCZIApi)\"."]
pub type ObjectHandle = ::std::os::raw::c_long;
unsafe extern "C" {
    #[doc = " (Immutable) Reserved value indicating an invalid object handle."]
    #[link_name = "\u{1}_ZL20kInvalidObjectHandle"]
    pub static kInvalidObjectHandle: ObjectHandle;
}
#[doc = " Defines an alias representing the handle of a CZI-reader object."]
pub type CziReaderObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a sub-block object."]
pub type SubBlockObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of an input stream object."]
pub type InputStreamObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of an output stream object."]
pub type OutputStreamObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a memory allocation object - which is \"a pointer to a memory block\", which must be\n freed with 'libCZI_Free'.\n TODO(JBL): this is not really used so far, should be removed I guess."]
pub type MemoryAllocationObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a bitmap object."]
pub type BitmapObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a metadata segment object."]
pub type MetadataSegmentObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of an attachment object."]
pub type AttachmentObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a writer object."]
pub type CziWriterObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a single-channel-scaling-tile-accessor."]
pub type SingleChannelScalingTileAccessorObjectHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a \"document info\" object."]
pub type CziDocumentInfoHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a \"display settings\" object."]
pub type DisplaySettingsHandle = ObjectHandle;
#[doc = " Defines an alias representing the handle of a \"channel display settings\" object."]
pub type ChannelDisplaySettingsHandle = ObjectHandle;
#[doc = " This struct contains the version information of the libCZIApi-library. For versioning libCZI, SemVer2 (<https://semver.org/>) is used.\n Note that the value of the tweak version number does not have a meaning (as far as SemVer2 is concerned)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibCZIVersionInfoInterop {
    #[doc = "< The major version number."]
    pub major: i32,
    #[doc = "< The minor version number."]
    pub minor: i32,
    #[doc = "< The patch version number."]
    pub patch: i32,
    #[doc = "< The tweak version number."]
    pub tweak: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LibCZIVersionInfoInterop"]
        [::std::mem::size_of::<LibCZIVersionInfoInterop>() - 16usize];
    ["Alignment of LibCZIVersionInfoInterop"]
        [::std::mem::align_of::<LibCZIVersionInfoInterop>() - 4usize];
    ["Offset of field: LibCZIVersionInfoInterop::major"]
        [::std::mem::offset_of!(LibCZIVersionInfoInterop, major) - 0usize];
    ["Offset of field: LibCZIVersionInfoInterop::minor"]
        [::std::mem::offset_of!(LibCZIVersionInfoInterop, minor) - 4usize];
    ["Offset of field: LibCZIVersionInfoInterop::patch"]
        [::std::mem::offset_of!(LibCZIVersionInfoInterop, patch) - 8usize];
    ["Offset of field: LibCZIVersionInfoInterop::tweak"]
        [::std::mem::offset_of!(LibCZIVersionInfoInterop, tweak) - 12usize];
};
#[doc = " This struct gives information about the build of the libCZIApi-library.\n Note that all strings must be freed by the caller (using libCZI_Free)."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LibCZIBuildInformationInterop {
    #[doc = "< If non-null, the compiler identification. This is a free-form string. This string must be freed by the caller (using libCZI_Free)."]
    pub compilerIdentification: *mut ::std::os::raw::c_char,
    #[doc = "< If non-null, the URL of the repository. This string must be freed by the caller (using libCZI_Free)."]
    pub repositoryUrl: *mut ::std::os::raw::c_char,
    #[doc = "< If non-null, the branch of the repository. This string must be freed by the caller (using libCZI_Free)."]
    pub repositoryBranch: *mut ::std::os::raw::c_char,
    #[doc = "< If non-null, the tag of the repository. This string must be freed by the caller (using libCZI_Free)."]
    pub repositoryTag: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LibCZIBuildInformationInterop"]
        [::std::mem::size_of::<LibCZIBuildInformationInterop>() - 32usize];
    ["Alignment of LibCZIBuildInformationInterop"]
        [::std::mem::align_of::<LibCZIBuildInformationInterop>() - 4usize];
    ["Offset of field: LibCZIBuildInformationInterop::compilerIdentification"]
        [::std::mem::offset_of!(LibCZIBuildInformationInterop, compilerIdentification) - 0usize];
    ["Offset of field: LibCZIBuildInformationInterop::repositoryUrl"]
        [::std::mem::offset_of!(LibCZIBuildInformationInterop, repositoryUrl) - 8usize];
    ["Offset of field: LibCZIBuildInformationInterop::repositoryBranch"]
        [::std::mem::offset_of!(LibCZIBuildInformationInterop, repositoryBranch) - 16usize];
    ["Offset of field: LibCZIBuildInformationInterop::repositoryTag"]
        [::std::mem::offset_of!(LibCZIBuildInformationInterop, repositoryTag) - 24usize];
};
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct InputStreamClassInfoInterop {
    #[doc = "< The name of the input stream class. This is a free-form string. This string must be freed by the caller (using libCZI_Free)."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< The description of the input stream class. This is a free-form string. This string must be freed by the caller (using libCZI_Free)."]
    pub description: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InputStreamClassInfoInterop"]
        [::std::mem::size_of::<InputStreamClassInfoInterop>() - 16usize];
    ["Alignment of InputStreamClassInfoInterop"]
        [::std::mem::align_of::<InputStreamClassInfoInterop>() - 4usize];
    ["Offset of field: InputStreamClassInfoInterop::name"]
        [::std::mem::offset_of!(InputStreamClassInfoInterop, name) - 0usize];
    ["Offset of field: InputStreamClassInfoInterop::description"]
        [::std::mem::offset_of!(InputStreamClassInfoInterop, description) - 8usize];
};
#[doc = "< Error code for \"an unspecified error occurred\"."]
pub const kStreamErrorCode_UnspecifiedError: ::std::os::raw::c_int = 1;
#[doc = " This structure gives additional information about an error that occurred in the external stream."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ExternalStreamErrorInfoInterop {
    #[doc = "< The error code - possible values are the constants kStreamErrorCode_XXX."]
    pub error_code: ::std::os::raw::c_int,
    #[doc = "< The error message (zero-terminated UTF8-encoded string). This string must be allocated with 'libCZI_AllocateMemory'."]
    pub error_message: MemoryAllocationObjectHandle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExternalStreamErrorInfoInterop"]
        [::std::mem::size_of::<ExternalStreamErrorInfoInterop>() - 12usize];
    ["Alignment of ExternalStreamErrorInfoInterop"]
        [::std::mem::align_of::<ExternalStreamErrorInfoInterop>() - 4usize];
    ["Offset of field: ExternalStreamErrorInfoInterop::error_code"]
        [::std::mem::offset_of!(ExternalStreamErrorInfoInterop, error_code) - 0usize];
    ["Offset of field: ExternalStreamErrorInfoInterop::error_message"]
        [::std::mem::offset_of!(ExternalStreamErrorInfoInterop, error_message) - 4usize];
};
#[doc = " This structure contains information about externally provided functions for reading data from an input stream,\n and it is used to construct a stream-object to be used with libCZI.\n Note on lifetime: The function pointers must remain valid until the function 'close_function' is called. The lifetime\n may extend beyond calling the 'libCZI_ReleaseInputStream' function for the corresponding stream-object."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ExternalInputStreamStructInterop {
    #[doc = " A user parameter which is passed to the callback function."]
    pub opaque_handle1: ::std::os::raw::c_ulong,
    #[doc = " A user parameter which is passed to the callback function."]
    pub opaque_handle2: ::std::os::raw::c_ulong,
    #[doc = " Function pointer used to read data from the stream.\n This function might be called from an arbitrary thread, and it may be called concurrently from multiple threads.\n A 0 as return value indicates successful operation. A non-zero value indicates a non-recoverable error.\n In case of an error, the error_info parameter must be filled with the error information.\n\n \\param          opaque_handle1  The value of the opaque_handle1 field of the ExternalInputStreamStructInterop.\n \\param          opaque_handle2  The value of the opaque_handle2 field of the ExternalInputStreamStructInterop.\n \\param          offset          The offset in the stream where to start reading from.\n \\param [out]    pv              Pointer to the buffer where the data is to be stored.\n \\param          size            The size of the buffer (and the number of bytes to be read from the stream).\n \\param [out]    ptrBytesRead    If non-null, the number of bytes that actually could be read is to be put here.\n \\param [out]    error_info      If non-null, in case of an error (i.e. return value <>0), this parameter may be used to report additional error information."]
    pub read_function: ::std::option::Option<
        unsafe extern "C" fn(
            opaque_handle1: ::std::os::raw::c_ulong,
            opaque_handle2: ::std::os::raw::c_ulong,
            offset: ::std::os::raw::c_ulong,
            pv: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_ulong,
            ptrBytesRead: *mut ::std::os::raw::c_ulong,
            error_info: *mut ExternalStreamErrorInfoInterop,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Function pointer used to close the stream. This function is called only once, and up until this function is called,\n the read_function pointer must remain valid and operational. No assumptions should be made about when this\n function is called, so the implementation must be prepared to handle this function being called at any time\n (but not concurrently with calls to the read_function).\n\n \\param  opaque_handle1  The value of the opaque_handle1 field of the ExternalInputStreamStructInterop.\n \\param  opaque_handle2  The value of the opaque_handle2 field of the ExternalInputStreamStructInterop."]
    pub close_function: ::std::option::Option<
        unsafe extern "C" fn(
            opaque_handle1: ::std::os::raw::c_ulong,
            opaque_handle2: ::std::os::raw::c_ulong,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExternalInputStreamStructInterop"]
        [::std::mem::size_of::<ExternalInputStreamStructInterop>() - 32usize];
    ["Alignment of ExternalInputStreamStructInterop"]
        [::std::mem::align_of::<ExternalInputStreamStructInterop>() - 4usize];
    ["Offset of field: ExternalInputStreamStructInterop::opaque_handle1"]
        [::std::mem::offset_of!(ExternalInputStreamStructInterop, opaque_handle1) - 0usize];
    ["Offset of field: ExternalInputStreamStructInterop::opaque_handle2"]
        [::std::mem::offset_of!(ExternalInputStreamStructInterop, opaque_handle2) - 8usize];
    ["Offset of field: ExternalInputStreamStructInterop::read_function"]
        [::std::mem::offset_of!(ExternalInputStreamStructInterop, read_function) - 16usize];
    ["Offset of field: ExternalInputStreamStructInterop::close_function"]
        [::std::mem::offset_of!(ExternalInputStreamStructInterop, close_function) - 24usize];
};
#[doc = " This structure contains information about externally provided functions for writing data to an output stream,\n and it is used to construct a stream-object to be used with libCZI.\n Note on lifetime: The function pointers must remain valid until the function 'close_function' is called. The lifetime\n may extend beyond calling the 'libCZI_ReleaseOutputStream' function for the corresponding stream-object."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ExternalOutputStreamStructInterop {
    #[doc = " A user parameter which is passed to the callback function."]
    pub opaque_handle1: ::std::os::raw::c_ulong,
    #[doc = " A user parameter which is passed to the callback function."]
    pub opaque_handle2: ::std::os::raw::c_ulong,
    #[doc = " Function pointer used to write data into the stream.\n This function might be called from an arbitrary thread, and it may be called concurrently from multiple threads.\n A 0 as return value indicates successful operation. A non-zero value indicates a non-recoverable error.\n In case of an error, the error_info parameter must be filled with the error information.\n\n \\param          opaque_handle1    The value of the opaque_handle1 field of the ExternalOutputStreamStructInterop.\n \\param          opaque_handle2    The value of the opaque_handle2 field of the ExternalOutputStreamStructInterop.\n \\param          offset            The offset in the stream where to start writing to.\n \\param [in]     pv                Pointer to the buffer with the data to be written.\n \\param          size              The size of the buffer (and the number of bytes to be written to the stream).\n \\param [out]    out_bytes_written If non-null, the number of bytes that actually could be written is to be put here.\n \\param [out]    error_info      If non-null, in case of an error (i.e. return value <>0), this parameter may be used to report additional error information."]
    pub write_function: ::std::option::Option<
        unsafe extern "C" fn(
            opaque_handle1: ::std::os::raw::c_ulong,
            opaque_handle2: ::std::os::raw::c_ulong,
            offset: ::std::os::raw::c_ulong,
            pv: *const ::std::os::raw::c_void,
            size: ::std::os::raw::c_ulong,
            out_bytes_written: *mut ::std::os::raw::c_ulong,
            error_info: *mut ExternalStreamErrorInfoInterop,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Function pointer used to close the stream. This function is called only once, and up until this function is called,\n the write_function pointer must remain valid and operational. No assumptions should be made about when this\n function is called, so the implementation must be prepared to handle this function being called at any time\n (but not concurrently with calls to the read_function).\n\n \\param  opaque_handle1  The value of the opaque_handle1 field of the ExternalOutputStreamStructInterop.\n \\param  opaque_handle2  The value of the opaque_handle2 field of the ExternalOutputStreamStructInterop."]
    pub close_function: ::std::option::Option<
        unsafe extern "C" fn(
            opaque_handle1: ::std::os::raw::c_ulong,
            opaque_handle2: ::std::os::raw::c_ulong,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExternalOutputStreamStructInterop"]
        [::std::mem::size_of::<ExternalOutputStreamStructInterop>() - 32usize];
    ["Alignment of ExternalOutputStreamStructInterop"]
        [::std::mem::align_of::<ExternalOutputStreamStructInterop>() - 4usize];
    ["Offset of field: ExternalOutputStreamStructInterop::opaque_handle1"]
        [::std::mem::offset_of!(ExternalOutputStreamStructInterop, opaque_handle1) - 0usize];
    ["Offset of field: ExternalOutputStreamStructInterop::opaque_handle2"]
        [::std::mem::offset_of!(ExternalOutputStreamStructInterop, opaque_handle2) - 8usize];
    ["Offset of field: ExternalOutputStreamStructInterop::write_function"]
        [::std::mem::offset_of!(ExternalOutputStreamStructInterop, write_function) - 16usize];
    ["Offset of field: ExternalOutputStreamStructInterop::close_function"]
        [::std::mem::offset_of!(ExternalOutputStreamStructInterop, close_function) - 24usize];
};
#[doc = " This structure gather the information needed to create a reader object."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ReaderOpenInfoInterop {
    #[doc = "< The input stream object to use for opening the file."]
    pub streamObject: InputStreamObjectHandle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ReaderOpenInfoInterop"][::std::mem::size_of::<ReaderOpenInfoInterop>() - 8usize];
    ["Alignment of ReaderOpenInfoInterop"]
        [::std::mem::align_of::<ReaderOpenInfoInterop>() - 4usize];
    ["Offset of field: ReaderOpenInfoInterop::streamObject"]
        [::std::mem::offset_of!(ReaderOpenInfoInterop, streamObject) - 0usize];
};
#[doc = "< Invalid dimension index."]
pub const kDimensionInvalid: ::std::os::raw::c_uint = 0;
#[doc = "< The Z-dimension."]
pub const kDimensionZ: ::std::os::raw::c_uint = 1;
#[doc = "< The C-dimension (\"channel\")."]
pub const kDimensionC: ::std::os::raw::c_uint = 2;
#[doc = "< The T-dimension (\"time\")."]
pub const kDimensionT: ::std::os::raw::c_uint = 3;
#[doc = "< The R-dimension (\"rotation\")."]
pub const kDimensionR: ::std::os::raw::c_uint = 4;
#[doc = "< The S-dimension (\"scene\")."]
pub const kDimensionS: ::std::os::raw::c_uint = 5;
#[doc = "< The I-dimension (\"illumination\")."]
pub const kDimensionI: ::std::os::raw::c_uint = 6;
#[doc = "< The H-dimension (\"phase\")."]
pub const kDimensionH: ::std::os::raw::c_uint = 7;
#[doc = "< The V-dimension (\"view\")."]
pub const kDimensionV: ::std::os::raw::c_uint = 8;
#[doc = "< The B-dimension (\"block\") - its use is deprecated."]
pub const kDimensionB: ::std::os::raw::c_uint = 9;
#[doc = "< This enum must have the value of the lowest (valid) dimension index."]
pub const kDimensionMinValue: ::std::os::raw::c_uint = 1;
#[doc = "< This enum must have the value of the highest (valid) dimension index."]
pub const kDimensionMaxValue: ::std::os::raw::c_uint = 9;
pub const kMaxDimensionCount: ::std::os::raw::c_uchar = 9;
#[doc = " This structure describes a rectangle, given by its top-left corner and its width and height."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntRectInterop {
    #[doc = "< The x-coordinate of the top-left corner."]
    pub x: ::std::os::raw::c_int,
    #[doc = "< The y-coordinate of the top-left corner."]
    pub y: ::std::os::raw::c_int,
    #[doc = "< The width of the rectangle."]
    pub w: ::std::os::raw::c_int,
    #[doc = "< The height of the rectangle."]
    pub h: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IntRectInterop"][::std::mem::size_of::<IntRectInterop>() - 16usize];
    ["Alignment of IntRectInterop"][::std::mem::align_of::<IntRectInterop>() - 4usize];
    ["Offset of field: IntRectInterop::x"][::std::mem::offset_of!(IntRectInterop, x) - 0usize];
    ["Offset of field: IntRectInterop::y"][::std::mem::offset_of!(IntRectInterop, y) - 4usize];
    ["Offset of field: IntRectInterop::w"][::std::mem::offset_of!(IntRectInterop, w) - 8usize];
    ["Offset of field: IntRectInterop::h"][::std::mem::offset_of!(IntRectInterop, h) - 12usize];
};
#[doc = " This structure describes a size, given by its width and height."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntSizeInterop {
    #[doc = "< The width."]
    pub w: ::std::os::raw::c_int,
    #[doc = "< The height."]
    pub h: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IntSizeInterop"][::std::mem::size_of::<IntSizeInterop>() - 8usize];
    ["Alignment of IntSizeInterop"][::std::mem::align_of::<IntSizeInterop>() - 4usize];
    ["Offset of field: IntSizeInterop::w"][::std::mem::offset_of!(IntSizeInterop, w) - 0usize];
    ["Offset of field: IntSizeInterop::h"][::std::mem::offset_of!(IntSizeInterop, h) - 4usize];
};
#[doc = " This structure gives the bounds for a set of dimensions.\n The bit at position `i` in `dimensions_valid` indicates whether the interval for dimension `i+1` is valid. So, bit 0\n is corresponding to dimension 1 (=Z), bit 1 to dimension 2 (=C), and so on.\n In the fixed-sized arrays `start` and `size`, the start and size values for the dimensions are stored. The elements at\n position 0 corresponds to the first valid dimension, the element at position 1 to the second valid dimension, and so on.\n An example would be: `dimensions_valid` = 0b00000011, `start` = { 0, 2 }, `size` = { 5, 6 }. This would mean that the\n dimension 'Z' is valid, and the interval is [0, 5], and the dimension 'C' is valid, and the interval is [2, 8]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DimBoundsInterop {
    #[doc = "< Bitfield indicating which dimensions are valid. Bit-position `i` corresponds to dimension `i+1`."]
    pub dimensions_valid: ::std::os::raw::c_uint,
    #[doc = "< The start values, the element 0 corresponds the first set flag in dimensions_valid and so on."]
    pub start: [::std::os::raw::c_int; 9usize],
    #[doc = "< The size values, the element 0 corresponds the first set flag in dimensions_valid and so on."]
    pub size: [::std::os::raw::c_int; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DimBoundsInterop"][::std::mem::size_of::<DimBoundsInterop>() - 76usize];
    ["Alignment of DimBoundsInterop"][::std::mem::align_of::<DimBoundsInterop>() - 4usize];
    ["Offset of field: DimBoundsInterop::dimensions_valid"]
        [::std::mem::offset_of!(DimBoundsInterop, dimensions_valid) - 0usize];
    ["Offset of field: DimBoundsInterop::start"]
        [::std::mem::offset_of!(DimBoundsInterop, start) - 4usize];
    ["Offset of field: DimBoundsInterop::size"]
        [::std::mem::offset_of!(DimBoundsInterop, size) - 40usize];
};
#[doc = " This structure gives the coordinates (of a sub-block) for a set of dimension.\n The bit at position `i` in `dimensions_valid` indicates whether the coordinate for dimension `i+1` is valid. So, bit 0\n is corresponding to dimension 1 (=Z), bit 1 to dimension 2 (=C), and so on.\n In the fixed-sized array `value`, the coordinate for the dimensions is stored. The element at\n position 0 corresponds to the first valid dimension, the element at position 1 to the second valid dimension, and so on.\n An example would be: `dimensions_valid` = 0b00000011, `value` = { 0, 2 }. This would mean that the\n dimension 'Z' is valid, and the coordinate for 'Z' is 0, and the dimension 'C' is valid, and the coordinate for 'C' is 2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoordinateInterop {
    #[doc = "< Bitfield indicating which dimensions are valid. Bit-position `i` corresponds to dimension `i+1`."]
    pub dimensions_valid: ::std::os::raw::c_uint,
    #[doc = "< The coordinate values, the element 0 corresponds the first set flag in dimensions_valid and so on."]
    pub value: [::std::os::raw::c_int; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CoordinateInterop"][::std::mem::size_of::<CoordinateInterop>() - 40usize];
    ["Alignment of CoordinateInterop"][::std::mem::align_of::<CoordinateInterop>() - 4usize];
    ["Offset of field: CoordinateInterop::dimensions_valid"]
        [::std::mem::offset_of!(CoordinateInterop, dimensions_valid) - 0usize];
    ["Offset of field: CoordinateInterop::value"]
        [::std::mem::offset_of!(CoordinateInterop, value) - 4usize];
};
#[doc = " This structure contains the bounding boxes for a scene."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BoundingBoxesInterop {
    #[doc = " Zero-based index of the scene (for which the following bounding boxes apply)."]
    pub sceneIndex: ::std::os::raw::c_int,
    #[doc = " The bounding box of the scene (calculated including pyramid-tiles)."]
    pub bounding_box: IntRectInterop,
    #[doc = " The bounding box of the scene (calculated excluding pyramid-tiles)."]
    pub bounding_box_layer0_only: IntRectInterop,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BoundingBoxesInterop"][::std::mem::size_of::<BoundingBoxesInterop>() - 36usize];
    ["Alignment of BoundingBoxesInterop"][::std::mem::align_of::<BoundingBoxesInterop>() - 4usize];
    ["Offset of field: BoundingBoxesInterop::sceneIndex"]
        [::std::mem::offset_of!(BoundingBoxesInterop, sceneIndex) - 0usize];
    ["Offset of field: BoundingBoxesInterop::bounding_box"]
        [::std::mem::offset_of!(BoundingBoxesInterop, bounding_box) - 4usize];
    ["Offset of field: BoundingBoxesInterop::bounding_box_layer0_only"]
        [::std::mem::offset_of!(BoundingBoxesInterop, bounding_box_layer0_only) - 20usize];
};
#[doc = " This structure contains basic statistics about an CZI-document."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubBlockStatisticsInterop {
    #[doc = "< The number of sub-blocks."]
    pub sub_block_count: ::std::os::raw::c_int,
    #[doc = "< The minimum M-index."]
    pub min_m_index: ::std::os::raw::c_int,
    #[doc = "< The maximum M-index."]
    pub max_m_index: ::std::os::raw::c_int,
    #[doc = "< The bounding-box determined from all sub-blocks."]
    pub bounding_box: IntRectInterop,
    #[doc = "< The minimal axis-aligned-bounding box determined only from the logical coordinates of the sub-blocks on pyramid-layer0 in the document."]
    pub bounding_box_layer0: IntRectInterop,
    #[doc = "< The dimension bounds."]
    pub dim_bounds: DimBoundsInterop,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubBlockStatisticsInterop"]
        [::std::mem::size_of::<SubBlockStatisticsInterop>() - 120usize];
    ["Alignment of SubBlockStatisticsInterop"]
        [::std::mem::align_of::<SubBlockStatisticsInterop>() - 4usize];
    ["Offset of field: SubBlockStatisticsInterop::sub_block_count"]
        [::std::mem::offset_of!(SubBlockStatisticsInterop, sub_block_count) - 0usize];
    ["Offset of field: SubBlockStatisticsInterop::min_m_index"]
        [::std::mem::offset_of!(SubBlockStatisticsInterop, min_m_index) - 4usize];
    ["Offset of field: SubBlockStatisticsInterop::max_m_index"]
        [::std::mem::offset_of!(SubBlockStatisticsInterop, max_m_index) - 8usize];
    ["Offset of field: SubBlockStatisticsInterop::bounding_box"]
        [::std::mem::offset_of!(SubBlockStatisticsInterop, bounding_box) - 12usize];
    ["Offset of field: SubBlockStatisticsInterop::bounding_box_layer0"]
        [::std::mem::offset_of!(SubBlockStatisticsInterop, bounding_box_layer0) - 28usize];
    ["Offset of field: SubBlockStatisticsInterop::dim_bounds"]
        [::std::mem::offset_of!(SubBlockStatisticsInterop, dim_bounds) - 44usize];
};
#[doc = " This structure extends on the basic statistics about an CZI-document, and includes per-scene statistics."]
#[repr(C)]
#[derive(Debug)]
pub struct SubBlockStatisticsInteropEx {
    #[doc = "< The number of sub-blocks."]
    pub sub_block_count: ::std::os::raw::c_int,
    #[doc = "< The minimum M-index."]
    pub min_m_index: ::std::os::raw::c_int,
    #[doc = "< The maximum M-index."]
    pub max_m_index: ::std::os::raw::c_int,
    #[doc = "< The bounding-box determined from all sub-blocks."]
    pub bounding_box: IntRectInterop,
    #[doc = "< The minimal axis-aligned-bounding box determined only from the logical coordinates of the sub-blocks on pyramid-layer0 in the document."]
    pub bounding_box_layer0: IntRectInterop,
    #[doc = "< The dimension bounds."]
    pub dim_bounds: DimBoundsInterop,
    #[doc = "< The number of per-scene bounding boxes that are following here."]
    pub number_of_per_scenes_bounding_boxes: ::std::os::raw::c_int,
    #[doc = "< The per-scene bounding boxes. The number of elements in this array is given by 'number_of_per_scenes_bounding_boxes'."]
    pub per_scenes_bounding_boxes: __IncompleteArrayField<BoundingBoxesInterop>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubBlockStatisticsInteropEx"]
        [::std::mem::size_of::<SubBlockStatisticsInteropEx>() - 124usize];
    ["Alignment of SubBlockStatisticsInteropEx"]
        [::std::mem::align_of::<SubBlockStatisticsInteropEx>() - 4usize];
    ["Offset of field: SubBlockStatisticsInteropEx::sub_block_count"]
        [::std::mem::offset_of!(SubBlockStatisticsInteropEx, sub_block_count) - 0usize];
    ["Offset of field: SubBlockStatisticsInteropEx::min_m_index"]
        [::std::mem::offset_of!(SubBlockStatisticsInteropEx, min_m_index) - 4usize];
    ["Offset of field: SubBlockStatisticsInteropEx::max_m_index"]
        [::std::mem::offset_of!(SubBlockStatisticsInteropEx, max_m_index) - 8usize];
    ["Offset of field: SubBlockStatisticsInteropEx::bounding_box"]
        [::std::mem::offset_of!(SubBlockStatisticsInteropEx, bounding_box) - 12usize];
    ["Offset of field: SubBlockStatisticsInteropEx::bounding_box_layer0"]
        [::std::mem::offset_of!(SubBlockStatisticsInteropEx, bounding_box_layer0) - 28usize];
    ["Offset of field: SubBlockStatisticsInteropEx::dim_bounds"]
        [::std::mem::offset_of!(SubBlockStatisticsInteropEx, dim_bounds) - 44usize];
    ["Offset of field: SubBlockStatisticsInteropEx::number_of_per_scenes_bounding_boxes"][::std::mem::offset_of!(
        SubBlockStatisticsInteropEx,
        number_of_per_scenes_bounding_boxes
    )
        - 120usize];
    ["Offset of field: SubBlockStatisticsInteropEx::per_scenes_bounding_boxes"]
        [::std::mem::offset_of!(SubBlockStatisticsInteropEx, per_scenes_bounding_boxes) - 124usize];
};
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct MetadataAsXmlInterop {
    #[doc = "< The XML-metadata. The data is an UTF8-encoded string. Note that this string is NOT guaranteed to be null-terminated.\n< This is a pointer to the data. This data must be freed by the caller (using libCZI_Free)."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< The size of the XML-metadata in bytes."]
    pub size: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MetadataAsXmlInterop"][::std::mem::size_of::<MetadataAsXmlInterop>() - 16usize];
    ["Alignment of MetadataAsXmlInterop"][::std::mem::align_of::<MetadataAsXmlInterop>() - 4usize];
    ["Offset of field: MetadataAsXmlInterop::data"]
        [::std::mem::offset_of!(MetadataAsXmlInterop, data) - 0usize];
    ["Offset of field: MetadataAsXmlInterop::size"]
        [::std::mem::offset_of!(MetadataAsXmlInterop, size) - 8usize];
};
#[doc = " Information about the bitmap represented by a bitmap-object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapInfoInterop {
    #[doc = "< The width of the bitmap in pixels."]
    pub width: ::std::os::raw::c_uint,
    #[doc = "< The height of the bitmap in pixels."]
    pub height: ::std::os::raw::c_uint,
    #[doc = "< The pixel type of the bitmap."]
    pub pixelType: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BitmapInfoInterop"][::std::mem::size_of::<BitmapInfoInterop>() - 12usize];
    ["Alignment of BitmapInfoInterop"][::std::mem::align_of::<BitmapInfoInterop>() - 4usize];
    ["Offset of field: BitmapInfoInterop::width"]
        [::std::mem::offset_of!(BitmapInfoInterop, width) - 0usize];
    ["Offset of field: BitmapInfoInterop::height"]
        [::std::mem::offset_of!(BitmapInfoInterop, height) - 4usize];
    ["Offset of field: BitmapInfoInterop::pixelType"]
        [::std::mem::offset_of!(BitmapInfoInterop, pixelType) - 8usize];
};
#[doc = " This structure contains information about a locked bitmap-object, allowing direct\n access to the pixel data."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct BitmapLockInfoInterop {
    #[doc = "< Not currently used, to be ignored."]
    pub ptrData: *mut ::std::os::raw::c_void,
    #[doc = "< The pointer to the first (top-left) pixel of the bitmap."]
    pub ptrDataRoi: *mut ::std::os::raw::c_void,
    #[doc = "< The stride of the bitmap data (pointed to by `ptrDataRoi`)."]
    pub stride: ::std::os::raw::c_uint,
    #[doc = "< The size of the bitmap data (pointed to by `ptrDataRoi`) in bytes."]
    pub size: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BitmapLockInfoInterop"][::std::mem::size_of::<BitmapLockInfoInterop>() - 28usize];
    ["Alignment of BitmapLockInfoInterop"]
        [::std::mem::align_of::<BitmapLockInfoInterop>() - 4usize];
    ["Offset of field: BitmapLockInfoInterop::ptrData"]
        [::std::mem::offset_of!(BitmapLockInfoInterop, ptrData) - 0usize];
    ["Offset of field: BitmapLockInfoInterop::ptrDataRoi"]
        [::std::mem::offset_of!(BitmapLockInfoInterop, ptrDataRoi) - 8usize];
    ["Offset of field: BitmapLockInfoInterop::stride"]
        [::std::mem::offset_of!(BitmapLockInfoInterop, stride) - 16usize];
    ["Offset of field: BitmapLockInfoInterop::size"]
        [::std::mem::offset_of!(BitmapLockInfoInterop, size) - 20usize];
};
#[doc = " This structure contains the information about a sub-block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubBlockInfoInterop {
    #[doc = "< The (raw) compression mode identification of the sub-block. This value is not interpreted, use \"GetCompressionMode\" to have it\n< converted to the CompressionMode-enumeration."]
    pub compression_mode_raw: ::std::os::raw::c_int,
    #[doc = "< The pixel type of the bitmap contained in the sub-block."]
    pub pixel_type: ::std::os::raw::c_int,
    #[doc = "< The coordinate of the sub-block."]
    pub coordinate: CoordinateInterop,
    #[doc = "< The rectangle where the bitmap (in this sub-block) is located (in the CZI-pixel-coordinate system)."]
    pub logical_rect: IntRectInterop,
    #[doc = "< The physical size of the bitmap of the sub-block (which may be different to the size of logicalRect)."]
    pub physical_size: IntSizeInterop,
    #[doc = "< The M-index. If this has the value of 'numeric_limits<int32_t>::min()', then the M-index is not valid."]
    pub m_index: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubBlockInfoInterop"][::std::mem::size_of::<SubBlockInfoInterop>() - 76usize];
    ["Alignment of SubBlockInfoInterop"][::std::mem::align_of::<SubBlockInfoInterop>() - 4usize];
    ["Offset of field: SubBlockInfoInterop::compression_mode_raw"]
        [::std::mem::offset_of!(SubBlockInfoInterop, compression_mode_raw) - 0usize];
    ["Offset of field: SubBlockInfoInterop::pixel_type"]
        [::std::mem::offset_of!(SubBlockInfoInterop, pixel_type) - 4usize];
    ["Offset of field: SubBlockInfoInterop::coordinate"]
        [::std::mem::offset_of!(SubBlockInfoInterop, coordinate) - 8usize];
    ["Offset of field: SubBlockInfoInterop::logical_rect"]
        [::std::mem::offset_of!(SubBlockInfoInterop, logical_rect) - 48usize];
    ["Offset of field: SubBlockInfoInterop::physical_size"]
        [::std::mem::offset_of!(SubBlockInfoInterop, physical_size) - 64usize];
    ["Offset of field: SubBlockInfoInterop::m_index"]
        [::std::mem::offset_of!(SubBlockInfoInterop, m_index) - 72usize];
};
#[doc = " This structure contains the information about an attachment.\n Note that performance reasons we use a fixed-size array for the name. In the rare case that the name is too long to fit into the\n fixed-size array, the 'overflow' field is set to true. In this case, the name is truncated and the 'overflow' field is set to true.\n In addition, the field 'name_in_case_of_overflow' then contains the full text, allocated with 'libCZI_AllocateString' (and responsibility\n for releasing the memory is with the caller)."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct AttachmentInfoInterop {
    #[doc = "< The GUID of the attachment."]
    pub guid: [::std::os::raw::c_uchar; 16usize],
    #[doc = "< A null-terminated character array identifying the content of the attachment."]
    pub content_file_type: [::std::os::raw::c_uchar; 9usize],
    #[doc = "< A zero-terminated string (in UTF8-encoding) identifying the content of the attachment."]
    pub name: [::std::os::raw::c_char; 255usize],
    #[doc = "< True if the name is too long to fit into the 'name' field."]
    pub name_overflow: bool,
    #[doc = "< If 'name_overflow' is true, then this field contains the name (in UTF8-encoding and zero terminated) of the attachment. This memory must be freed using 'libCZI_Free'."]
    pub name_in_case_of_overflow: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AttachmentInfoInterop"][::std::mem::size_of::<AttachmentInfoInterop>() - 292usize];
    ["Alignment of AttachmentInfoInterop"]
        [::std::mem::align_of::<AttachmentInfoInterop>() - 4usize];
    ["Offset of field: AttachmentInfoInterop::guid"]
        [::std::mem::offset_of!(AttachmentInfoInterop, guid) - 0usize];
    ["Offset of field: AttachmentInfoInterop::content_file_type"]
        [::std::mem::offset_of!(AttachmentInfoInterop, content_file_type) - 16usize];
    ["Offset of field: AttachmentInfoInterop::name"]
        [::std::mem::offset_of!(AttachmentInfoInterop, name) - 25usize];
    ["Offset of field: AttachmentInfoInterop::name_overflow"]
        [::std::mem::offset_of!(AttachmentInfoInterop, name_overflow) - 280usize];
    ["Offset of field: AttachmentInfoInterop::name_in_case_of_overflow"]
        [::std::mem::offset_of!(AttachmentInfoInterop, name_in_case_of_overflow) - 284usize];
};
#[doc = " This structure contains the information about file-header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileHeaderInfoInterop {
    #[doc = "< The file-GUID of the CZI. Note: CZI defines two GUIDs, this is the \"FileGuid\". Multi-file containers\n< (for which the other GUID \"PrimaryFileGuid\" is used) are not supported by libCZI currently."]
    pub guid: [::std::os::raw::c_uchar; 16usize],
    #[doc = "< The major version."]
    pub majorVersion: ::std::os::raw::c_int,
    #[doc = "< The minor version."]
    pub minorVersion: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FileHeaderInfoInterop"][::std::mem::size_of::<FileHeaderInfoInterop>() - 24usize];
    ["Alignment of FileHeaderInfoInterop"]
        [::std::mem::align_of::<FileHeaderInfoInterop>() - 4usize];
    ["Offset of field: FileHeaderInfoInterop::guid"]
        [::std::mem::offset_of!(FileHeaderInfoInterop, guid) - 0usize];
    ["Offset of field: FileHeaderInfoInterop::majorVersion"]
        [::std::mem::offset_of!(FileHeaderInfoInterop, majorVersion) - 16usize];
    ["Offset of field: FileHeaderInfoInterop::minorVersion"]
        [::std::mem::offset_of!(FileHeaderInfoInterop, minorVersion) - 20usize];
};
#[doc = " This structure is used to pass the subblock information to libCZIAPI, describing a subblock to be added to a CZI-file."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct AddSubBlockInfoInterop {
    #[doc = "< The subblock's coordinate."]
    pub coordinate: CoordinateInterop,
    #[doc = "< Whether the field 'mIndex' is valid;"]
    pub m_index_valid: ::std::os::raw::c_uchar,
    #[doc = "< The M-index of the subblock."]
    pub m_index: ::std::os::raw::c_int,
    #[doc = "< The x-coordinate of the subblock."]
    pub x: ::std::os::raw::c_int,
    #[doc = "< The y-coordinate of the subblock."]
    pub y: ::std::os::raw::c_int,
    #[doc = "< The logical with of the subblock (in pixels)."]
    pub logical_width: ::std::os::raw::c_int,
    #[doc = "< The logical height of the subblock (in pixels)."]
    pub logical_height: ::std::os::raw::c_int,
    #[doc = "< The physical with of the subblock (in pixels)."]
    pub physical_width: ::std::os::raw::c_int,
    #[doc = "< The physical height of the subblock (in pixels)."]
    pub physical_height: ::std::os::raw::c_int,
    #[doc = "< The pixel type of the subblock."]
    pub pixel_type: ::std::os::raw::c_int,
    #[doc = " The compression-mode (applying to the subblock-data). If using a compressed format, the data\n passed in must be already compressed - the writer does _not_ perform the compression."]
    pub compression_mode_raw: ::std::os::raw::c_int,
    #[doc = "< The size of the subblock's data in bytes."]
    pub size_data: ::std::os::raw::c_uint,
    #[doc = "< Pointer to the data to be put into the subblock."]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " If the compression mode is set to 'Uncompressed', then this is valid and the stride of the bitmap.\n In this case, the line-size of the bitmap is determined by the pixel-type and the physical_width.\n And size_data must be large enough to hold the bitmap-data, and is validated.\n In other cases (compression-mode is not 'Uncompressed'), this field is ignored."]
    pub stride: ::std::os::raw::c_uint,
    #[doc = "< The size of the subblock-metadata in bytes. If this is 0, then ptrSbBlkMetadata is not used (and no sub-block-metadata written)."]
    pub size_metadata: ::std::os::raw::c_uint,
    #[doc = "< Pointer to the subblock-metadata."]
    pub metadata: *const ::std::os::raw::c_void,
    #[doc = "< The size of the subblock-attachment in bytes. If this is 0, then attachment is not used (and no sub-block-metadata written)."]
    pub size_attachment: ::std::os::raw::c_uint,
    #[doc = "< Pointer to the subblock-attachment."]
    pub attachment: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddSubBlockInfoInterop"][::std::mem::size_of::<AddSubBlockInfoInterop>() - 120usize];
    ["Alignment of AddSubBlockInfoInterop"]
        [::std::mem::align_of::<AddSubBlockInfoInterop>() - 4usize];
    ["Offset of field: AddSubBlockInfoInterop::coordinate"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, coordinate) - 0usize];
    ["Offset of field: AddSubBlockInfoInterop::m_index_valid"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, m_index_valid) - 40usize];
    ["Offset of field: AddSubBlockInfoInterop::m_index"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, m_index) - 44usize];
    ["Offset of field: AddSubBlockInfoInterop::x"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, x) - 48usize];
    ["Offset of field: AddSubBlockInfoInterop::y"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, y) - 52usize];
    ["Offset of field: AddSubBlockInfoInterop::logical_width"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, logical_width) - 56usize];
    ["Offset of field: AddSubBlockInfoInterop::logical_height"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, logical_height) - 60usize];
    ["Offset of field: AddSubBlockInfoInterop::physical_width"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, physical_width) - 64usize];
    ["Offset of field: AddSubBlockInfoInterop::physical_height"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, physical_height) - 68usize];
    ["Offset of field: AddSubBlockInfoInterop::pixel_type"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, pixel_type) - 72usize];
    ["Offset of field: AddSubBlockInfoInterop::compression_mode_raw"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, compression_mode_raw) - 76usize];
    ["Offset of field: AddSubBlockInfoInterop::size_data"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, size_data) - 80usize];
    ["Offset of field: AddSubBlockInfoInterop::data"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, data) - 84usize];
    ["Offset of field: AddSubBlockInfoInterop::stride"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, stride) - 92usize];
    ["Offset of field: AddSubBlockInfoInterop::size_metadata"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, size_metadata) - 96usize];
    ["Offset of field: AddSubBlockInfoInterop::metadata"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, metadata) - 100usize];
    ["Offset of field: AddSubBlockInfoInterop::size_attachment"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, size_attachment) - 108usize];
    ["Offset of field: AddSubBlockInfoInterop::attachment"]
        [::std::mem::offset_of!(AddSubBlockInfoInterop, attachment) - 112usize];
};
#[doc = " This structure is used to pass the attachment information to libCZIAPI, describing an attachment to be added to a CZI-file."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct AddAttachmentInfoInterop {
    #[doc = "< The GUID of the attachment."]
    pub guid: [::std::os::raw::c_uchar; 16usize],
    #[doc = "< The content file type."]
    pub contentFileType: [::std::os::raw::c_uchar; 8usize],
    #[doc = "< The name of the attachment."]
    pub name: [::std::os::raw::c_uchar; 80usize],
    #[doc = "< The size of the attachment data (in bytes)."]
    pub size_attachment_data: ::std::os::raw::c_uint,
    #[doc = "< Pointer to the attachment data."]
    pub attachment_data: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddAttachmentInfoInterop"]
        [::std::mem::size_of::<AddAttachmentInfoInterop>() - 116usize];
    ["Alignment of AddAttachmentInfoInterop"]
        [::std::mem::align_of::<AddAttachmentInfoInterop>() - 4usize];
    ["Offset of field: AddAttachmentInfoInterop::guid"]
        [::std::mem::offset_of!(AddAttachmentInfoInterop, guid) - 0usize];
    ["Offset of field: AddAttachmentInfoInterop::contentFileType"]
        [::std::mem::offset_of!(AddAttachmentInfoInterop, contentFileType) - 16usize];
    ["Offset of field: AddAttachmentInfoInterop::name"]
        [::std::mem::offset_of!(AddAttachmentInfoInterop, name) - 24usize];
    ["Offset of field: AddAttachmentInfoInterop::size_attachment_data"]
        [::std::mem::offset_of!(AddAttachmentInfoInterop, size_attachment_data) - 104usize];
    ["Offset of field: AddAttachmentInfoInterop::attachment_data"]
        [::std::mem::offset_of!(AddAttachmentInfoInterop, attachment_data) - 108usize];
};
#[doc = " This structure is used to pass the metadata information to libCZIAPI."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct WriteMetadataInfoInterop {
    #[doc = "< The size of the data pointed to by metadata."]
    pub size_metadata: ::std::os::raw::c_uint,
    #[doc = "< Pointer to the metadata. This data is expected to be XML in UTF8-encoding."]
    pub metadata: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of WriteMetadataInfoInterop"]
        [::std::mem::size_of::<WriteMetadataInfoInterop>() - 12usize];
    ["Alignment of WriteMetadataInfoInterop"]
        [::std::mem::align_of::<WriteMetadataInfoInterop>() - 4usize];
    ["Offset of field: WriteMetadataInfoInterop::size_metadata"]
        [::std::mem::offset_of!(WriteMetadataInfoInterop, size_metadata) - 0usize];
    ["Offset of field: WriteMetadataInfoInterop::metadata"]
        [::std::mem::offset_of!(WriteMetadataInfoInterop, metadata) - 4usize];
};
#[doc = " This structure is used to pass the accessor options to libCZIAPI."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct AccessorOptionsInterop {
    #[doc = " The red component of the background color. If the destination bitmap is a grayscale-type, then the mean from R, G and B is calculated and multiplied\n with the maximum pixel value (of the specific pixeltype). If it is an RGB-color type, then R, G and B are separately multiplied with\n the maximum pixel value.\n If any of R, G or B is NaN, then the background is not cleared."]
    pub back_ground_color_r: f32,
    #[doc = " The green component of the background color. If the destination bitmap is a grayscale-type, then the mean from R, G and B is calculated and multiplied\n with the maximum pixel value (of the specific pixeltype). If it is an RGB-color type, then R, G and B are separately multiplied with\n the maximum pixel value.\n If any of R, G or B is NaN, then the background is not cleared."]
    pub back_ground_color_g: f32,
    #[doc = " The blue component of the background color. If the destination bitmap is a grayscale-type, then the mean from R, G and B is calculated and multiplied\n with the maximum pixel value (of the specific pixeltype). If it is an RGB-color type, then R, G and B are separately multiplied with\n the maximum pixel value.\n If any of R, G or B is NaN, then the background is not cleared."]
    pub back_ground_color_b: f32,
    #[doc = " If true, then the tiles are sorted by their M-index (tile with highest M-index will be 'on top').\n Otherwise, the Z-order is arbitrary."]
    pub sort_by_m: bool,
    #[doc = " If true, then the tile-visibility-check-optimization is used. When doing the multi-tile composition,\n all relevant tiles are checked whether they are visible in the destination bitmap. If a tile is not visible, then\n the corresponding sub-block is not read. This can speed up the operation considerably. The result is the same as\n without this optimization - i.e. there should be no reason to turn it off besides potential bugs."]
    pub use_visibility_check_optimization: bool,
    #[doc = " Additional parameters for the accessor."]
    pub additional_parameters: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccessorOptionsInterop"][::std::mem::size_of::<AccessorOptionsInterop>() - 24usize];
    ["Alignment of AccessorOptionsInterop"]
        [::std::mem::align_of::<AccessorOptionsInterop>() - 4usize];
    ["Offset of field: AccessorOptionsInterop::back_ground_color_r"]
        [::std::mem::offset_of!(AccessorOptionsInterop, back_ground_color_r) - 0usize];
    ["Offset of field: AccessorOptionsInterop::back_ground_color_g"]
        [::std::mem::offset_of!(AccessorOptionsInterop, back_ground_color_g) - 4usize];
    ["Offset of field: AccessorOptionsInterop::back_ground_color_b"]
        [::std::mem::offset_of!(AccessorOptionsInterop, back_ground_color_b) - 8usize];
    ["Offset of field: AccessorOptionsInterop::sort_by_m"]
        [::std::mem::offset_of!(AccessorOptionsInterop, sort_by_m) - 12usize];
    ["Offset of field: AccessorOptionsInterop::use_visibility_check_optimization"][::std::mem::offset_of!(
        AccessorOptionsInterop,
        use_visibility_check_optimization
    ) - 13usize];
    ["Offset of field: AccessorOptionsInterop::additional_parameters"]
        [::std::mem::offset_of!(AccessorOptionsInterop, additional_parameters) - 16usize];
};
#[doc = " This structure gathers all information about a channel for the purpose of multi-channel-composition."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct CompositionChannelInfoInterop {
    #[doc = "< The weight of the channel in the composition."]
    pub weight: f32,
    #[doc = " True if tinting is enabled for this channel (in which case the tinting member is to be\n examined), false if no tinting is to be applied (the tinting member is then not used)."]
    pub enable_tinting: ::std::os::raw::c_uchar,
    #[doc = " The tinting color (only examined if enableTinting is true). This is the red-component."]
    pub tinting_color_r: ::std::os::raw::c_uchar,
    #[doc = " The tinting color (only examined if enableTinting is true). This is the green-component."]
    pub tinting_color_g: ::std::os::raw::c_uchar,
    #[doc = " The tinting color (only examined if enableTinting is true). This is the blue-component."]
    pub tinting_color_b: ::std::os::raw::c_uchar,
    #[doc = " The black point - it is a float between 0 and 1, where 0 corresponds to the lowest pixel value\n (of the pixel-type for the channel) and 1 to the highest pixel value (of the pixel-type of this channel).\n All pixel values below the black point are mapped to 0."]
    pub black_point: f32,
    #[doc = " The white point - it is a float between 0 and 1, where 0 corresponds to the lowest pixel value\n (of the pixel-type for the channel) and 1 to the highest pixel value (of the pixel-type of this channel).\n All pixel value above the white pointer are mapped to the highest pixel value."]
    pub white_point: f32,
    #[doc = " Number of elements in the look-up table. If 0, then the look-up table\n is not used. If this channelInfo applies to a Gray8/Bgr24-channel, then the size\n of the look-up table must be 256. In case of a Gray16/Bgr48-channel, the size must be\n 65536.\n \\remark\n If a look-up table is provided, then \\c blackPoint and \\c whitePoint are not used anymore ."]
    pub look_up_table_element_count: ::std::os::raw::c_int,
    #[doc = " The pointer to the look-up table. If the property 'look_up_table_element_count' is <> 0, then this pointer\n must be valid."]
    pub ptr_look_up_table: *mut ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CompositionChannelInfoInterop"]
        [::std::mem::size_of::<CompositionChannelInfoInterop>() - 28usize];
    ["Alignment of CompositionChannelInfoInterop"]
        [::std::mem::align_of::<CompositionChannelInfoInterop>() - 4usize];
    ["Offset of field: CompositionChannelInfoInterop::weight"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, weight) - 0usize];
    ["Offset of field: CompositionChannelInfoInterop::enable_tinting"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, enable_tinting) - 4usize];
    ["Offset of field: CompositionChannelInfoInterop::tinting_color_r"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, tinting_color_r) - 5usize];
    ["Offset of field: CompositionChannelInfoInterop::tinting_color_g"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, tinting_color_g) - 6usize];
    ["Offset of field: CompositionChannelInfoInterop::tinting_color_b"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, tinting_color_b) - 7usize];
    ["Offset of field: CompositionChannelInfoInterop::black_point"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, black_point) - 8usize];
    ["Offset of field: CompositionChannelInfoInterop::white_point"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, white_point) - 12usize];
    ["Offset of field: CompositionChannelInfoInterop::look_up_table_element_count"][::std::mem::offset_of!(
        CompositionChannelInfoInterop,
        look_up_table_element_count
    ) - 16usize];
    ["Offset of field: CompositionChannelInfoInterop::ptr_look_up_table"]
        [::std::mem::offset_of!(CompositionChannelInfoInterop, ptr_look_up_table) - 20usize];
};
#[doc = " This structure gathers the information about the scaling."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ScalingInfoInterop {
    #[doc = "< The length of a pixel in x-direction in the unit meters. If unknown/invalid, this value is numeric_limits<double>::quiet_NaN()."]
    pub scale_x: f64,
    #[doc = "< The length of a pixel in y-direction in the unit meters. If unknown/invalid, this value is numeric_limits<double>::quiet_NaN()."]
    pub scale_y: f64,
    #[doc = "< The length of a pixel in z-direction in the unit meters. If unknown/invalid, this value is numeric_limits<double>::quiet_NaN()."]
    pub scale_z: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScalingInfoInterop"][::std::mem::size_of::<ScalingInfoInterop>() - 24usize];
    ["Alignment of ScalingInfoInterop"][::std::mem::align_of::<ScalingInfoInterop>() - 4usize];
    ["Offset of field: ScalingInfoInterop::scale_x"]
        [::std::mem::offset_of!(ScalingInfoInterop, scale_x) - 0usize];
    ["Offset of field: ScalingInfoInterop::scale_y"]
        [::std::mem::offset_of!(ScalingInfoInterop, scale_y) - 8usize];
    ["Offset of field: ScalingInfoInterop::scale_z"]
        [::std::mem::offset_of!(ScalingInfoInterop, scale_z) - 16usize];
};
unsafe extern "C" {
    #[doc = " Release the memory - this function is to be used for freeing memory allocated by the libCZIApi-library\n (and returned to the caller).\n\n \\param  data    Pointer to the memory to be freed."]
    pub fn libCZI_Free(data: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Allocate memory of the specified size.\n\n \\param          size    The size of the memory block to be allocated in bytes.\n \\param [out]    data    If successful, a pointer to the allocated memory is put here. The memory must be freed using 'libCZI_Free'.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_AllocateMemory(
        size: ::std::os::raw::c_ulong,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get version information about the libCZIApi-library.\n\n \\param [out] version_info    If successful, the version information is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_GetLibCZIVersionInfo(
        version_info: *mut LibCZIVersionInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get information about the build of the libCZIApi-library.\n\n \\param [out] build_info  If successful, the build information is put here. Note that all strings must be freed by the caller (using 'libCZI_Free').\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_GetLibCZIBuildInformation(
        build_info: *mut LibCZIBuildInformationInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create a new CZI-reader object.\n\n \\param [out] reader_object If the operation is successful, a handle to the newly created reader object is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CreateReader(reader_object: *mut CziReaderObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Instruct the specified reader-object to open a CZI-document. The 'open_info' parameter contains\n a handle to a stream-object which is used to read the document.\n\n \\param  reader_object A handle representing the reader-object.\n \\param  open_info     Parameters controlling the operation.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderOpen(
        reader_object: CziReaderObjectHandle,
        open_info: *const ReaderOpenInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get information about the file-header of the CZI document. The information is put into the 'file_header_info_interop' structure.\n This file_header_info_interop structure contains the GUID of the CZI document and the version levels of CZI.\n\n \\param          reader_object               The reader object.\n \\param [out]    file_header_info_interop    If successful, the retrieved information is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderGetFileHeaderInfo(
        reader_object: CziReaderObjectHandle,
        file_header_info_interop: *mut FileHeaderInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Reads the sub-block identified by the specified index. If there is no sub-block present (for the\n specified index) then the function returns 'LibCZIApi_ErrorCode_OK', but the 'sub_block_object'\n is set to 'kInvalidObjectHandle'.\n\n \\param          reader_object       The reader object.\n \\param          index               Index of the sub-block.\n \\param [out]    sub_block_object    If successful, a handle to the sub-block object is put here; otherwise 'kInvalidObjectHandle'.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderReadSubBlock(
        reader_object: CziReaderObjectHandle,
        index: ::std::os::raw::c_int,
        sub_block_object: *mut SubBlockObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get statistics about the sub-blocks in the CZI-document. This function provides a simple version of the statistics, the\n information retrieved does not include the per-scene statistics.\n\n \\param          reader_object   The reader object.\n \\param [out]    statistics      If non-null, the simple statistics will be put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderGetStatisticsSimple(
        reader_object: CziReaderObjectHandle,
        statistics: *mut SubBlockStatisticsInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get extended statistics about the sub-blocks in the CZI-document. This function provides a more detailed version of the statistics,\n including the per-scene statistics. Note that the statistics is of variable size, and the semantic is as follows:\n - On input, the argument 'number_of_per_channel_bounding_boxes' must point to an integer which describes the size of the argument 'statistics'.\n   This number gives how many elements the array 'per_scenes_bounding_boxes' in 'SubBlockStatisticsInteropEx' can hold. Only that number of\n   per-scene information elements will be put into the 'statistics' structure at most, in any case.\n - On output, the argument 'number_of_per_channel_bounding_boxes' will be set to the number of per-channel bounding boxes that were actually\n   available.\n - In the returned 'SubBlockStatisticsInteropEx' structure, the 'number_of_per_scenes_bounding_boxes' field will be set to the number of per-scene\n   information that is put into this struct (which may be less than number of scenes that are available).\n So, the caller is expected to check the returned 'number_of_per_channel_bounding_boxes' to see how many per-channel bounding boxes are available.\n If this number is greater than the number of elements (given with the 'number_of_per_scenes_bounding_boxes' value in the 'statistics' structure),\n then the caller should allocate a larger 'statistics' structure and call this function again (with an increased 'number_of_per_scenes_bounding_boxes').\n\n \\param          reader_object                           The reader object.\n \\param [out]    statistics                              If non-null, the statistics will be put here.\n \\param [in,out] number_of_per_channel_bounding_boxes    On input, it gives the number of elements that can be put into the 'per_scenes_bounding_boxes' array.\n                                                         On output, it gives the number of elements which are available.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderGetStatisticsEx(
        reader_object: CziReaderObjectHandle,
        statistics: *mut SubBlockStatisticsInteropEx,
        number_of_per_channel_bounding_boxes: *mut ::std::os::raw::c_int,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get \"pyramid-statistics\" about the CZI-document. This function provides a JSON-formatted string which contains information about the pyramid.\n The JSON-schema is as follows:\n \\code\n {\n     \"scenePyramidStatistics\": {\n         \"<sceneIndex>\": [\n         {\n             \"layerInfo\": {\n             \"minificationFactor\": <number>,\n             \"pyramidLayerNo\" : <number>\n         },\n         \"count\" : <number>\n         }\n     ]}\n }\n \\endcode\n It resembles the corresponding C++-structure 'PyramidStatistics' in the libCZI-library.\n\n \\param          reader_object              The reader object.\n \\param [out]    pyramid_statistics_as_json If successful, a pointer to a JSON-formatted string is placed here. The caller\n                                             is responsible for freeing this memory (by calling libCZI_Free).\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderGetPyramidStatistics(
        reader_object: CziReaderObjectHandle,
        pyramid_statistics_as_json: *mut *mut ::std::os::raw::c_char,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create a metadata-segment object from the reader-object. The metadata-segment object can be used to retrieve the XML-metadata of the CZI-document.\n\n \\param          reader_object           The reader object.\n \\param [out]    metadata_segment_object If successful, a handle to the metadata-segment object is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderGetMetadataSegment(
        reader_object: CziReaderObjectHandle,
        metadata_segment_object: *mut MetadataSegmentObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the number of attachments available.\n\n \\param          reader_object           The reader object.\n \\param [out]    count                   The number of available attachments is put here.\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderGetAttachmentCount(
        reader_object: CziReaderObjectHandle,
        count: *mut ::std::os::raw::c_int,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get information about the attachment at the specified index. The information is put into the 'attachment_info_interop' structure.\n If the index is not valid, then the function returns 'LibCZIApi_ErrorCode_IndexOutOfRange'.\n\n \\param          reader_object           The reader object.\n \\param          index                   The index of the attachment to query information for.\n \\param [out]    attachment_info_interop If successful, the retrieved information is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderGetAttachmentInfoFromDirectory(
        reader_object: CziReaderObjectHandle,
        index: ::std::os::raw::c_int,
        attachment_info_interop: *mut AttachmentInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Read the attachment with the specified index and create an attachment object representing it. If the specified index\n is invalid, then the returned attachment-object handle will have the value 'kInvalidObjectHandle'.\n \\param       reader_object              The reader object.\n \\param       index                      The index of the attachment to get.\n \\param [out] attachment_object          If successful and index is valid, a handle representing the attachment object is put here. If the index is\n                                         invalid, then the handle will have the value 'kInvalidObjectHandle'.\n \\returns  An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReaderReadAttachment(
        reader_object: CziReaderObjectHandle,
        index: ::std::os::raw::c_int,
        attachment_object: *mut AttachmentObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified reader-object. After this function is called, the handle is no\n longer valid.\n\n \\param  reader_object   The reader object.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseReader(reader_object: CziReaderObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the number of available stream classes.\n\n \\param [out] count The number of available stream classes it put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_GetStreamClassesCount(count: *mut ::std::os::raw::c_int) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get information about the stream class at the specified index.\n\n \\param          index                   Zero-based index of the stream class to query information about.\n \\param [out]    input_stream_class_info If successful, information about the stream class is put here. Note that the strings in the structure\n                                         must be freed (by the caller) using 'libCZI_Free'.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_GetStreamClassInfo(
        index: ::std::os::raw::c_int,
        input_stream_class_info: *mut InputStreamClassInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create an input stream object of the specified type, using the specified JSON-formatted property bag and\n the specified file identifier as input.\n\n \\param          stream_class_name       Name of the stream class to be instantiated.\n \\param          creation_property_bag   JSON formatted string (containing additional parameters for the stream creation) in UTF8-encoding.\n \\param          stream_identifier       The filename (or, more generally, a URI of some sort) identifying the file to be opened in UTF8-encoding.\n \\param [out]    stream_object           If successful, a handle representing the newly created stream object is put here.\n\n \\returns    An error-code that indicates whether the operation is successful or not."]
    pub fn libCZI_CreateInputStream(
        stream_class_name: *const ::std::os::raw::c_char,
        creation_property_bag: *const ::std::os::raw::c_char,
        stream_identifier: *const ::std::os::raw::c_char,
        stream_object: *mut InputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create an input stream object for a file identified by its filename, which is given as a wide string. Note that wchar_t on\n Windows is 16-bit wide, and on Unix-like systems it is 32-bit wide.\n\n \\param  [in]    filename        Filename of the file which is to be opened (zero terminated wide string). Note that on Windows, this\n                                 is a string with 16-bit code units, and on Unix-like systems it is typically a string with 32-bit code units.\n\n \\param  [out]   stream_object   The output stream object that will hold the created stream.\n \\return         An error-code that indicates whether the operation is successful or not. Non-positive values indicates successful, positive values\n                 indicates unsuccessful operation."]
    pub fn libCZI_CreateInputStreamFromFileWide(
        filename: *const u32,
        stream_object: *mut InputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create an input stream object for a file identified by its filename, which is given as an UTF8-encoded string.\n\n \\param  [in]    filename        Filename of the file which is to be opened (in UTF8 encoding).\n \\param  [out]   stream_object   The output stream object that will hold the created stream.\n \\return         An error-code that indicates whether the operation is successful or not. Non-positive values indicates successful, positive values\n                 indicates unsuccessful operation."]
    pub fn libCZI_CreateInputStreamFromFileUTF8(
        filename: *const ::std::os::raw::c_char,
        stream_object: *mut InputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create an input stream object which is using externally provided functions for operation\n and reading the data. Please refer to the documentation of\n 'ExternalInputStreamStructInterop' for more information.\n\n \\param          external_input_stream_struct    Structure containing the information about the externally provided functions.\n \\param [out]    stream_object                   If successful, the handle to the newly created input stream object is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CreateInputStreamFromExternal(
        external_input_stream_struct: *const ExternalInputStreamStructInterop,
        stream_object: *mut InputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified input stream object. After this function is called, the handle is no\n longer valid. Note that calling this function will only decrement the usage count of the\n underlying object; whereas the object itself (and the resources it holds) will only be\n released when the usage count reaches zero.\n\n \\param  stream_object   The input stream object.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseInputStream(stream_object: InputStreamObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create a bitmap object from the specified sub-block object. The bitmap object can be used to access the pixel\n data contained in the sub-block. If the subblock contains compressed data, then decompression will be performed\n in this call.\n\n \\param          sub_block_object The sub-block object.\n \\param [out]    bitmap_object    If successful, the handle to the newly created bitmap object is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_SubBlockCreateBitmap(
        sub_block_object: SubBlockObjectHandle,
        bitmap_object: *mut BitmapObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get Information about the sub-block.\n\n \\param       sub_block_object The sub-block object.\n \\param [out] sub_block_info   If successful, information about the sub-block object is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_SubBlockGetInfo(
        sub_block_object: SubBlockObjectHandle,
        sub_block_info: *mut SubBlockInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Copy the raw data from the specified sub-block object to the specified memory buffer. The value of the 'size' parameter\n on input is the size of the buffer pointed to by 'data'. On output, the value of 'size' is the actual size of the data. At most\n the initial value of 'size' bytes are copied to the buffer. If the initial value of 'size' is zero (0) or 'data' is null, then\n no data is copied.\n For the 'type' parameter, the following values are valid: 0 (data) and 1 (metadata).\n For 0 (data), the data is the raw pixel data of the bitmap. This data may be compressed.\n For 1 (metadata), the data is the raw metadata in XML-format (UTF8-encoded).\n\n \\param          sub_block_object    The sub block object.\n \\param          type                The type - 0 for \"pixel-data\", 1 for \"sub-block metadata\".\n \\param [in,out] size                On input, the size of the memory block pointed to by 'data', on output the actual size of the available data.\n \\param [out]    data                Pointer where the data is to be copied to. At most the initial content of 'size' bytes are copied.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_SubBlockGetRawData(
        sub_block_object: SubBlockObjectHandle,
        type_: ::std::os::raw::c_int,
        size: *mut ::std::os::raw::c_ulong,
        data: *mut ::std::os::raw::c_void,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified sub-block object.\n\n \\param  sub_block_object The sub block object to be released.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseSubBlock(sub_block_object: SubBlockObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get information about the sub-block with the specified index. The information is put into the 'sub_block_info_interop' structure.\n If the index is not valid, then the function returns 'LibCZIApi_ErrorCode_IndexOutOfRange'.\n\n \\param          reader_object           The reader object.\n \\param          index                   The index of the attachment to query information for.\n \\param [out]    sub_block_info_interop  If successful, the retrieved information is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_TryGetSubBlockInfoForIndex(
        reader_object: CziReaderObjectHandle,
        index: ::std::os::raw::c_int,
        sub_block_info_interop: *mut SubBlockInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get information about the specified attachment object.\n \\param attachment_object            The attachment object.\n \\param [out]    attachment_info     Information about the attachment.\n \\returns     An error-code indicating success or failure of the operation."]
    pub fn libCZI_AttachmentGetInfo(
        attachment_object: AttachmentObjectHandle,
        attachment_info: *mut AttachmentInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Copy the raw data from the specified attachment object to the specified memory buffer. The value of the 'size' parameter\n on input is the size of the buffer pointed to by 'data'. On output, the value of 'size' is the actual size of the data. At most\n the initial value of 'size' bytes are copied to the buffer. If the initial value of 'size' is zero (0) or 'data' is null, then\n no data is copied.\n \\param          attachment_object   The attachment object.\n \\param [in,out] size                On input, the size of the memory block pointed to by 'data', on output the actual size of the available data.\n \\param [out]    data                Pointer where the data is to be copied to. At most the initial content of 'size' bytes are copied.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_AttachmentGetRawData(
        attachment_object: AttachmentObjectHandle,
        size: *mut ::std::os::raw::c_ulong,
        data: *mut ::std::os::raw::c_void,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified attachment object.\n\n \\param  attachment_object The attachment object to be released.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseAttachment(
        attachment_object: AttachmentObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get information about the specified bitmap object.\n\n \\param          bitmap_object The bitmap object.\n \\param [out]    bitmap_info   If successful, information about the bitmap object is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_BitmapGetInfo(
        bitmap_object: BitmapObjectHandle,
        bitmap_info: *mut BitmapInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Locks the bitmap object. Once the bitmap is locked, the pixel data can be accessed. Memory access to the\n pixel data must only occur while the bitmap is locked. The lock must be released by calling 'libCZI_BitmapUnlock'.\n It is a fatal error if the bitmap is destroyed while still being locked. Calls to Lock and Unlock are counted, and\n they must be balanced.\n\n \\param          bitmap_object The bitmap object.\n \\param [out]    lockInfo      If successful, information about how to access the pixel data is put here.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_BitmapLock(
        bitmap_object: BitmapObjectHandle,
        lockInfo: *mut BitmapLockInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Unlock the bitmap object. Once the bitmap is unlocked, the pixel data must not be accessed anymore.\n\n \\param  bitmap_object The bitmap object.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_BitmapUnlock(bitmap_object: BitmapObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Copy the pixel data from the specified bitmap object to the specified memory buffer. The specified\n destination bitmap must have same width, height and pixel type as the source bitmap.\n\n \\param          bitmap_object The bitmap object.\n \\param          width         The width of the destination bitmap.\n \\param          height        The height of the destination bitmap.\n \\param          pixel_type    The pixel type.\n \\param          stride        The stride (given in bytes).\n \\param [out]    ptr           Pointer to the memory location where the bitmap is to be copied to.\n\n \\returns A LibCZIApiErrorCode."]
    pub fn libCZI_BitmapCopyTo(
        bitmap_object: BitmapObjectHandle,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        pixel_type: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_uint,
        ptr: *mut ::std::os::raw::c_void,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified bitmap object.\n It is a fatal error trying to release a bitmap object that is still locked.\n\n \\param  bitmap_object The bitmap object.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseBitmap(bitmap_object: BitmapObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the XML-metadata information from the specified metadata-segment object.\n Note that the XML-metadata is returned as a pointer to the data (in the 'data' field of the 'MetadataAsXmlInterop' structure), which\n must be freed by the caller using 'libCZI_Free'.\n\n \\param          metadata_segment_object The metadata segment object.\n \\param [out]    metadata_as_xml_interop If successful, the XML-metadata information is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_MetadataSegmentGetMetadataAsXml(
        metadata_segment_object: MetadataSegmentObjectHandle,
        metadata_as_xml_interop: *mut MetadataAsXmlInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create a CZI-document-information object from the specified metadata-segment object.\n\n \\param          metadata_segment_object The metadata segment object.\n \\param [in,out] czi_document_info       If successful, a handle to the newly created CZI-document-info object is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_MetadataSegmentGetCziDocumentInfo(
        metadata_segment_object: MetadataSegmentObjectHandle,
        czi_document_info: *mut CziDocumentInfoHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified metadata-segment object.\n\n \\param  metadata_segment_object The metadata-segment object to be released.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseMetadataSegment(
        metadata_segment_object: MetadataSegmentObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get \"general document information\" from the specified czi-document information object. The information is returned as a JSON-formatted string.\n The JSON returned is an object, with the following possible key-value pairs:\n \"name\" : \"<name of the document>\", type string\n \"title\" : \"<title of the document>\", type string\n \"user_name\" : \"<user name>\", type string\n \"description\" : \"<description>\", type string\n \"comment\" : \"<comment>\", type string\n \"keywords\" : \"<keyword1>,<keyword2>,...\", type string\n \"rating\" : \"<rating>\", type integer\n \"creation_date\" : \"<creation date>\", type string, conforming to ISO 8601\n\n \\param          czi_document_info           The CZI-document-info object.\n \\param [out]    general_document_info_json  If successful, the general document information is put here. Note that the data must be freed using 'libCZI_Free' by the caller.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CziDocumentInfoGetGeneralDocumentInfo(
        czi_document_info: CziDocumentInfoHandle,
        general_document_info_json: *mut *mut ::std::os::raw::c_void,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get scaling information from the specified czi-document information object. The information gives the size of an image pixels.\n\n \\param          czi_document_info           Handle to the CZI-document-info object from which the scaling information will be retrieved.\n \\param [out]    scaling_info_interop        If successful, the scaling information is put here.\n\n \\returns        An error-code indicating success or failure of the operation."]
    pub fn libCZI_CziDocumentInfoGetScalingInfo(
        czi_document_info: CziDocumentInfoHandle,
        scaling_info_interop: *mut ScalingInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Retrieve the set of dimensions for which \"dimension info\" data is available. The argument 'available_dimensions_count' indicates the number of\n elements available, and this should be 'kMaxDimensionCount+1' at least. If the number of available dimensions is insufficient, the function will\n return an error (LibCZIApi_ErrorCode_InvalidArgument). The 'available_dimensions' array is filled with the available dimensions, and the list is\n terminated with a value of 'kInvalidDimensionIndex'.\n\n \\param          czi_document_info           The CZI-document-info object.\n \\param          available_dimensions_count  Number of elements available in the 'available_dimensions' array.\n \\param [in,out] available_dimensions        If successful, the available dimensions are put here. The list is terminated with a value of 'kInvalidDimensionIndex'.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CziDocumentInfoGetAvailableDimension(
        czi_document_info: CziDocumentInfoHandle,
        available_dimensions_count: ::std::os::raw::c_uint,
        available_dimensions: *mut ::std::os::raw::c_uint,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the display-settings from the document's XML-metadata. The display-settings are returned in the form of an object,\n for which a handle is returned.\n\n \\param          czi_document_info       The CZI-document-info object.\n \\param [in,out] display_settings_handle If successful, a handle to the display-settings object is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CziDocumentInfoGetDisplaySettings(
        czi_document_info: CziDocumentInfoHandle,
        display_settings_handle: *mut DisplaySettingsHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the dimension information from the document's XML-metadata. The information is returned as a JSON-formatted string.\n\n \\param          czi_document_info       Handle to the CZI-document-info object from which the dimension information will be retrieved.\n \\param          dimension_index         Index of the dimension.\n \\param [out]    dimension_info_json     If successful, the information is put here as JSON format. Note that the data must be freed using 'libCZI_Free' by the caller.\n\n \\returns        An error-code indicating success or failure of the operation."]
    pub fn libCZI_CziDocumentInfoGetDimensionInfo(
        czi_document_info: CziDocumentInfoHandle,
        dimension_index: ::std::os::raw::c_uint,
        dimension_info_json: *mut *mut ::std::os::raw::c_void,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified CZI-document-info object.\n\n \\param  czi_document_info The CZI-document-info object.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseCziDocumentInfo(
        czi_document_info: CziDocumentInfoHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create an output stream object for a file identified by its filename, which is given as a wide string. Note that wchar_t on\n Windows is 16-bit wide, and on Unix-like systems it is 32-bit wide.\n\n \\param          filename                Filename of the file which is to be opened (zero terminated wide string). Note that on Windows, this\n                                         is a string with 16-bit code units, and on Unix-like systems it is typically a string with 32-bit code units.\n \\param          overwrite               Indicates whether the file should be overwritten.\n \\param [out]    output_stream_object    The output stream object that will hold the created stream.\n\n \\return         An error-code that indicates whether the operation is successful or not. Non-positive values indicates successful, positive values\n                 indicates unsuccessful operation."]
    pub fn libCZI_CreateOutputStreamForFileWide(
        filename: *const u32,
        overwrite: bool,
        output_stream_object: *mut OutputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create an input stream object for a file identified by its filename, which is given as an UTF8 - encoded string.\n\n \\param          filename                Filename of the file which is to be opened (in UTF8 encoding).\n \\param          overwrite               Indicates whether the file should be overwritten.\n \\param [out]    output_stream_object    The output stream object that will hold the created stream.\n\n \\return         An error-code that indicates whether the operation is successful or not. Non-positive values indicates successful, positive values\n                 indicates unsuccessful operation."]
    pub fn libCZI_CreateOutputStreamForFileUTF8(
        filename: *const ::std::os::raw::c_char,
        overwrite: bool,
        output_stream_object: *mut OutputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified output stream object. After this function is called, the handle is no\n longer valid. Note that calling this function will only decrement the usage count of the\n underlying object; whereas the object itself (and the resources it holds) will only be\n released when the usage count reaches zero.\n\n \\param  output_stream_object   The output stream object.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseOutputStream(
        output_stream_object: OutputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create an output stream object which is using externally provided functions for operation\n and writing the data. Please refer to the documentation of\n 'ExternalOutputStreamStructInterop' for more information.\n\n \\param          external_output_stream_struct    Structure containing the information about the externally provided functions.\n \\param [out]    output_stream_object             If successful, the handle to the newly created output stream object is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CreateOutputStreamFromExternal(
        external_output_stream_struct: *const ExternalOutputStreamStructInterop,
        output_stream_object: *mut OutputStreamObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create a writer object for authoring a document in CZI-format. The options string is a JSON-formatted string, here\n is an example:\n \\code\n {\n \"allow_duplicate_subblocks\" : true\n }\n \\endcode\n\n \\param [out] writer_object If the operation is successful, a handle to the newly created writer object is put here.\n \\param       options       A JSON-formatted zero-terminated string (in UTF8-encoding) containing options for the writer creation.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_CreateWriter(
        writer_object: *mut CziWriterObjectHandle,
        options: *const ::std::os::raw::c_char,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Initializes the writer object with the specified output stream object. The options string is a JSON-formatted string, here\n is an example:\n \\code\n {\n \"file_guid\" : \"123e4567-e89b-12d3-a456-426614174000\",\n \"reserved_size_attachments_directory\" : 4096,\n \"reserved_size_metadata_segment\" : 50000,\n \"minimum_m_index\" : 0,\n \"maximum_m_index\" : 100\n }\n \\endcode\n\n \\param [out] writer_object If the operation is successful, a handle to the newly created writer object is put here.\n \\param       output_stream_object The output stream object to be used for writing the CZI data.\n \\param       parameters       A JSON-formatted zero-terminated string (in UTF8-encoding) containing options for the writer initialization.\n\n \\returns An error-code indicating success or failure of the operation."]
    pub fn libCZI_WriterCreate(
        writer_object: CziWriterObjectHandle,
        output_stream_object: OutputStreamObjectHandle,
        parameters: *const ::std::os::raw::c_char,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Add the specified sub-block to the writer object. The sub-block information is provided in the 'add_sub_block_info_interop' structure.\n\n \\param  writer_object               The writer object.\n \\param  add_sub_block_info_interop  Information describing the sub-block to be added.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_WriterAddSubBlock(
        writer_object: CziWriterObjectHandle,
        add_sub_block_info_interop: *const AddSubBlockInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Add the specified attachment to the writer object. The attachment is provided in the 'add_attachment_info_interop' structure.\n\n \\param  writer_object               The writer object.\n \\param  add_attachment_info_interop Information describing the attachment to be added.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_WriterAddAttachment(
        writer_object: CziWriterObjectHandle,
        add_attachment_info_interop: *const AddAttachmentInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Add the specified metadata to the writer object. The metadata is provided in the 'write_metadata_info_interop' structure.\n\n \\param  writer_object               Handle to the writer object to which the metadata will be added.\n \\param  write_metadata_info_interop Information describing the metadata to be added.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_WriterWriteMetadata(
        writer_object: CziWriterObjectHandle,
        write_metadata_info_interop: *const WriteMetadataInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Finalizes the CZI (i.e. writes out the final directory-segments) and closes the file.\n Note that this method must be called explicitly in order to get a valid CZI - calling 'libCZI_ReleaseWriter' without\n a prior call to this method will close the file immediately without finalization.\n\n \\param  writer_object   Handle to the writer object that is to be closed.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_WriterClose(writer_object: CziWriterObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified writer object.\n\n \\param  writer_object Handle to the writer object that is to be released.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseWriter(writer_object: CziWriterObjectHandle) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Create a single channel scaling tile accessor.\n\n \\param reader_object            A handle representing the reader-object.\n \\param accessor_object [out]    If the operation is successful, a handle to the newly created single-channel-scaling-tile-accessor is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CreateSingleChannelTileAccessor(
        reader_object: CziReaderObjectHandle,
        accessor_object: *mut SingleChannelScalingTileAccessorObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Gets the size information of the specified tile accessor based on the region of interest and zoom factor.\n\n \\param  accessor_object     Handle to the tile accessor object for which the size is to be calculated. This object is responsible for managing the access to the tiles within the specified plane.\n \\param  roi                 The region of interest that defines the region of interest within the plane for which the size is to be calculated.\n \\param  zoom                A floating-point value representing the zoom factor.\n \\param  size [out]          The size of the tile accessor. It contains width and height information.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_SingleChannelTileAccessorCalcSize(
        accessor_object: SingleChannelScalingTileAccessorObjectHandle,
        roi: *const IntRectInterop,
        zoom: f32,
        size: *mut IntSizeInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Gets the tile bitmap of the specified plane and the specified roi with the specified zoom factor.\n\n \\param  accessor_object         Handle to the tile accessor object. This object is responsible for managing the access to the tiles within the specified plane.\n \\param  coordinate              Pointer to a `CoordinateInterop` structure that specifies the coordinates within the plane from which the tile bitmap is to be retrieved.\n \\param  roi                     The region of interest that defines within the plane for which the tile bitmap is requested.\n \\param  zoom                    A floating-point value representing the zoom factor.\n \\param  options                 A pointer to an AccessorOptionsInterop structure that may contain additional options for accessing the tile bitmap.\n \\param  bitmap_object [out]     If the operation is successful, the created bitmap object will be put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_SingleChannelTileAccessorGet(
        accessor_object: SingleChannelScalingTileAccessorObjectHandle,
        coordinate: *const CoordinateInterop,
        roi: *const IntRectInterop,
        zoom: f32,
        options: *const AccessorOptionsInterop,
        bitmap_object: *mut BitmapObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified accessor object.\n\n \\param  accessor_object      The accessor object.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseCreateSingleChannelTileAccessor(
        accessor_object: SingleChannelScalingTileAccessorObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Given a display-settings object and the channel-number, this function fills out the\n composition-channel-information which is needed for the multi-channel-composition.\n Note that in the returned 'CompositionChannelInfoInterop' structure, the 'lut' field is a pointer to the LUT-data,\n which must be freed with 'libCZI_Free' by the caller.\n\n \\param          display_settings_handle             The display settings handle.\n \\param          channel_index                       The channel-index (referring to the display settings object) we are concerned with.\n \\param          sixteen_or_eight_bits_lut           True for generating a 16-bit LUT; if false, then an 8-bit LUT is generated.\n \\param [out]    composition_channel_info_interop    The composition channel information is put here.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_CompositorFillOutCompositionChannelInfoInterop(
        display_settings_handle: DisplaySettingsHandle,
        channel_index: ::std::os::raw::c_int,
        sixteen_or_eight_bits_lut: bool,
        composition_channel_info_interop: *mut CompositionChannelInfoInterop,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Perform a multi-channel-composition operation. The source bitmaps are provided in the 'source_bitmaps' array, and the\n array of 'CompositionChannelInfoInterop' structures provide the information needed for the composition. The resulting bitmap\n is then put into the 'bitmap_object' handle.\n\n \\param       channelCount       The number of channels - this defines the size of the 'source_bitmaps' and 'channel_info' arrays.\n \\param       source_bitmaps     The array of source bitmaps.\n \\param       channel_info       The array of channel information.\n \\param [out] bitmap_object      The resulting bitmap is put here.\n\n \\return     An error-code indicating success or failure of the operation."]
    pub fn libCZI_CompositorDoMultiChannelComposition(
        channelCount: ::std::os::raw::c_int,
        source_bitmaps: *const BitmapObjectHandle,
        channel_info: *const CompositionChannelInfoInterop,
        bitmap_object: *mut BitmapObjectHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    pub fn libCZI_DisplaySettingsGetChannelDisplaySettings(
        display_settings_handle: DisplaySettingsHandle,
        channel_id: ::std::os::raw::c_int,
        channel_display_setting: *mut ChannelDisplaySettingsHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified display settings object.\n\n \\param  display_settings_handle      The display settings object.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseDisplaySettings(
        display_settings_handle: DisplaySettingsHandle,
    ) -> LibCZIApiErrorCode;
}
unsafe extern "C" {
    #[doc = " Release the specified channel-display settings object.\n\n \\param  channel_display_settings_handle      The channel-display settings object.\n\n \\returns    An error-code indicating success or failure of the operation."]
    pub fn libCZI_ReleaseChannelDisplaySettings(
        channel_display_settings_handle: ChannelDisplaySettingsHandle,
    ) -> LibCZIApiErrorCode;
}
